class class 1
test ID 1
{ { 1

 Terminator 1
public accessModifier 2
function function 2
funct ID 2
( ( 2
) ) 2
{ { 2

 Terminator 2
return return 3
5 IntConst 3

 Terminator 3

 Terminator 4
} } 5

 Terminator 5

 Terminator 6
public accessModifier 7
function function 7
fn ID 7
( ( 7
) ) 7
{ { 7

 Terminator 7

 Terminator 8
} } 9

 Terminator 9
} } 10

 Terminator 10

 Terminator 11
class class 12
baseClass ID 12
{ { 12

 Terminator 12
protected accessModifier 13
int DT 13
y ID 13

 Terminator 13

 Terminator 14
public accessModifier 15
function function 15
fn ID 15
( ( 15
) ) 15
{ { 15

 Terminator 15

 Terminator 16
} } 17

 Terminator 17

 Terminator 18
} } 19

 Terminator 19

 Terminator 20
abstract abstract 21
class class 21
myclass ID 21
extends extends 21
baseClass ID 21
{ { 21

 Terminator 21

 Terminator 22
private accessModifier 23
var DT 23
z ID 23

 Terminator 23
private accessModifier 24
test ID 24
x ID 24
= = 24
new new 24
test ID 24
[ [ 24
5 IntConst 24
] ] 24

 Terminator 24

 Terminator 25
private accessModifier 26
myclass ID 26
( ( 26
) ) 26
{ { 26

 Terminator 26
this this 27
-> -> 27
x ID 27
= = 27
y ID 27

 Terminator 27
b ID 28
++ inc_dec 28

 Terminator 28
this this 29
-> -> 29
y ID 29
= = 29
x ID 29

 Terminator 29

 Terminator 30
} } 31

 Terminator 31

 Terminator 32
public accessModifier 33
virtual virtual 33
function function 33
init ID 33
( ( 33
# # 33
a ID 33
, , 33
b ID 33
) ) 33
{ { 33

 Terminator 33

 Terminator 34
this this 35
-> -> 35
x ID 35
[ [ 35
i ID 35
] ] 35
. . 35
funct ID 35
( ( 35
) ) 35

 Terminator 35

 Terminator 36
loop loop 37
( ( 37
int DT 37
b ID 37
= = 37
1 IntConst 37
; ; 37
x ID 37
[ [ 37
3 IntConst 37
] ] 37
. . 37
fn ID 37
( ( 37
) ) 37
!= ROP 37
2 IntConst 37
; ; 37
b ID 37
++ inc_dec 37
) ) 37
{ { 37

 Terminator 37
break executionMod 38

 Terminator 38

 Terminator 39
if if 40
( ( 40
z ID 40
<= ROP 40
b ID 40
) ) 40
{ { 40

 Terminator 40
this this 41
-> -> 41
fn ID 41
( ( 41
) ) 41

 Terminator 41
} } 42

 Terminator 42

 Terminator 43

 Terminator 44
} } 45

 Terminator 45
} } 46

 Terminator 46

 Terminator 47
} } 48

 Terminator 48

 Terminator 49
static static 50
function function 50
name ID 50
( ( 50
x ID 50
, , 50
y ID 50
) ) 50
{ { 50

 Terminator 50
float DT 51
a ID 51

 Terminator 51
int DT 52
b ID 52

 Terminator 52
int DT 53
c ID 53
= = 53
a ID 53
* MDM 53
b ID 53
<= ROP 53
b ID 53
+ PM 53
a ID 53

 Terminator 53

 Terminator 54
return return 55
a ID 55
+ PM 55
b ID 55

 Terminator 55

 Terminator 56
} } 57

 Terminator 57

 Terminator 58
int DT 59
a ID 59
= = 59
true BoolConst 59
, , 59
b ID 59
= = 59
7 IntConst 59

 Terminator 59

 Terminator 60
myclass ID 61
myobj ID 61
= = 61
new new 61
myclass ID 61
( ( 61
) ) 61

 Terminator 61
myobj ID 62
. . 62
init ID 62
( ( 62
a ID 62
, , 62
b ID 62
) ) 62

 Terminator 62
myobj ID 63
. . 63
y ID 63
= = 63
b ID 63

 Terminator 63

 Terminator 64
int DT 65
# # 65
myvar ID 65
= = 65
new new 65
int DT 65

 Terminator 65

 Terminator 66

 Terminator 67
loop loop 68
( ( 68
int DT 68
b ID 68
= = 68
1 IntConst 68
; ; 68
a ID 68
< ROP 68
b ID 68
+ PM 68
3 IntConst 68
&& && 68
a ID 68
[ [ 68
a ID 68
+ PM 68
b ID 68
* MDM 68
g ID 68
< ROP 68
v ID 68
&& && 68
4 IntConst 68
] ] 68
. . 68
fn ID 68
( ( 68
) ) 68
!= ROP 68
2 IntConst 68
; ; 68
b ID 68
++ inc_dec 68
) ) 68
{ { 68

 Terminator 68
fn ID 69
( ( 69
) ) 69

 Terminator 69
string DT 70
b ID 70

 Terminator 70

 Terminator 71

 Terminator 72
break executionMod 73

 Terminator 73
} } 74

 Terminator 74

 Terminator 75
if if 76
( ( 76
i ID 76
< ROP 76
b ID 76
( ( 76
z ID 76
+ PM 76
a ID 76
) ) 76
- PM 76
9 IntConst 76
) ) 76

 Terminator 76
{ { 77

 Terminator 77
myclass ID 78
:: :: 78
z ID 78
. . 78
funct ID 78
( ( 78
) ) 78

 Terminator 78
string DT 79
arr ID 79
= = 79
new new 79
[ [ 79
i ID 79
+ PM 79
c ID 79
] ] 79

 Terminator 79
float DT 80
mynewvar ID 80
= = 80
a ID 80
+ PM 80
c ID 80

 Terminator 80

 Terminator 81
} } 82

 Terminator 82
$ $ 83
